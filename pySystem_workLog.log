pySystem
========

python manage.py runserver

#Validate Modles
python manage.py validate

#Genrate SQL Equivalent (Not work with Migrate)
python manage.py sqlall sysadmin

----------------------------------
BEGIN;
CREATE TABLE `sysadmin_logintype` (
    `id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY,
    `login_id` varchar(10) NOT NULL,
    `login_type_name` varchar(30) NOT NULL,
    `login_type` varchar(40) NOT NULL
)
;
CREATE TABLE `sysadmin_loginmanagement` (
    `id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY,
    `login_name` varchar(30) NOT NULL,
    `first_name` varchar(30) NOT NULL,
    `last_name` varchar(40) NOT NULL,
    `login_levelid_id` integer NOT NULL,
    `login_pwd` varchar(30) NOT NULL,
    `email` varchar(75) NOT NULL,
    `city` varchar(60) NOT NULL,
    `state_province` varchar(30) NOT NULL,
    `country` varchar(50) NOT NULL,
    `create_date` datetime(6) NOT NULL
)
;

ALTER TABLE `sysadmin_loginmanagement` ADD CONSTRAINT `login_levelid_id` FOREIGN KEY (`login_levelid_id`) REFERENCES `sysadmin_logintype` (`id`);
CREATE INDEX `sysadmin_loginmanagement` ON `sysadmin_loginmanagement` (`login_levelid_id`);

COMMIT;

----------------------------------

#Django provides an easier way of committing the SQL to the database. Run the syncdb command, like so:

$ python manage.py syncdb

Operations to perform:
  Synchronize unmigrated apps: sysadmin
  Apply all migrations: (none)
Synchronizing apps without migrations:
  Creating tables...
    Creating table sysadmin_logintype
    Creating table sysadmin_loginmanagement
  Installing custom SQL...
  Installing indexes...
Running migrations:
  No migrations to apply.


BASIC DATA ACCESS

python manage.py shell


from sysadmin.models import Logintype
p1 = Logintype( login_id=1,login_type_name="admin",login_type=1)
p1.save()

>>from sysadmin.models import Logintype
>>logintype_list = Logintype.objects.all()
>>logintype_list

from sysadmin.models import Loginmanagement
p2 = Loginmanagement( login_name="rahul",first_name="Rahul",last_name="Prasad",login_levelid_id=1,login_pwd="rahul",email="prasad@rahul.com",
city="Bangaore",state_province="KA",country="IN")
p2.save()


ADDING MODEL STRING REPRESENTATIONS (by adding a method called __str__() in model class)

from sysadmin.models import Loginmanagement
loginmanagement_list = Loginmanagement.objects.all()
loginmanagement_list

Out[3]: [<Loginmanagement: rahul Rahul Prasad>]

---------------------
MODEL OPERATIONS
---------------------
SELECTING OBJECTS:

>>> Loginmanagement.objects.all()
[<Loginmanagement: Addison-Wesley>, <Loginmanagement: O'Reilly>, <Loginmanagement: Apress Publishing>]

This roughly translates to this SQL:

SELECT
id, name, address, city, state_province, country, website
FROM book_Loginmanagement;


Filtering Data:

While fetching all objects certainly has its uses, most of the time we’re going to want to deal with a subset of the data. We’ll
do this with the filter() method:

>>> Loginmanagement.objects.filter(name="Apress Publishing")
[<Loginmanagement: Apress Publishing>]

filter() takes keyword arguments that get translated into the appropriate SQL WHERE clauses.

SELECT
id, name, address, city, state_province, country, website
FROM book_Loginmanagement
WHERE name = 'Apress Publishing';

Retrieving Single Objects:

Sometimes you want to fetch only a single object. That’s what the get() method is for:
>>> Loginmanagement.objects.get(name="Apress Publishing")
<Loginmanagement: Apress Publishing>

Instead of a list (rather, QuerySet), only a single object is returned. Because of that, a query resulting in multiple objects will
cause an exception:

>>> Loginmanagement.objects.get(name="Penguin")
Traceback (most recent call last):
...
DoesNotExist: Loginmanagement matching query does not exist.

Ordering Data:

>>> Loginmanagement.objects.order_by("name")
[<Loginmanagement: Apress Publishing>, <Loginmanagement: Addison-Wesley>, <Loginmanagement:
O'Reilly>]

This doesn’t look much different from the earlier all() example, but the SQL now includes a specific ordering:

SELECT
id, name, address, city, state_province, country, website
FROM book_Loginmanagement


Chaining Lookups:

Loginmanagement.objects.filter(country="U.S.A.").order_by("-name")
[<Loginmanagement: O'Reilly>, <Loginmanagement: Apress Publishing>, <Loginmanagement:
Addison-Wesley>]

SELECT
id, name, address, city, state_province, country, website
FROM book_Loginmanagement
WHERE country = 'U.S.A'
ORDER BY name DESC;

Slicing Data:

Loginmanagement.objects.all()[0]
<Loginmanagement: Addison-Wesley>


SELECT
id, name, address, city, state_province, country, website
FROM book_Loginmanagement
ORDER BY name
LIMIT 1;


)